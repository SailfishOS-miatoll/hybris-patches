From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Matti Lehtimaki <matti.lehtimaki@gmail.com>
Date: Mon, 27 Feb 2023 16:49:56 +0200
Subject: [PATCH] (hybris) Revert "Returns a service parse error on overrides
 across the treble boundary."

This reverts commit f597fa5d1dca3b79b30d5b66e15e23b0bd91b560.
---
 init/host_init_verifier.cpp | 86 +++++++------------------------------
 init/service.cpp            |  1 -
 init/service.h              |  2 -
 init/service_parser.cpp     |  8 ----
 init/subcontext.cpp         |  3 --
 init/subcontext.h           |  7 +--
 6 files changed, 18 insertions(+), 89 deletions(-)

diff --git a/init/host_init_verifier.cpp b/init/host_init_verifier.cpp
index db127d3f2b27c23f9007c8ef72045de97ac54f3a..ef9a4514c4241c40fb6508a9bfaa0f180ad2f7c0 100644
--- a/init/host_init_verifier.cpp
+++ b/init/host_init_verifier.cpp
@@ -25,8 +25,6 @@
 #include <fstream>
 #include <iostream>
 #include <iterator>
-#include <map>
-#include <set>
 #include <string>
 #include <vector>
 
@@ -53,7 +51,6 @@
 
 using namespace std::literals;
 
-using android::base::EndsWith;
 using android::base::ParseInt;
 using android::base::ReadFileToString;
 using android::base::Split;
@@ -64,10 +61,6 @@ using android::properties::PropertyInfoEntry;
 
 static std::vector<std::string> passwd_files;
 
-// NOTE: Keep this in sync with the order used by init.cpp LoadBootScripts()
-static const std::vector<std::string> partition_search_order =
-        std::vector<std::string>({"system", "system_ext", "odm", "vendor", "product"});
-
 static std::vector<std::pair<std::string, int>> GetVendorPasswd(const std::string& passwd_file) {
     std::string passwd;
     if (!ReadFileToString(passwd_file, &passwd)) {
@@ -155,24 +148,13 @@ static Result<void> check_stub(const BuiltinArguments& args) {
 #include "generated_stub_builtin_function_map.h"
 
 void PrintUsage() {
-    fprintf(stdout, R"(usage: host_init_verifier [options]
-
-Tests init script(s) for correctness.
-
-Generic options:
-  -p FILE                     Search this passwd file for users and groups.
-  --property_contexts=FILE    Use this file for property_contexts.
-
-Single script mode options:
-  [init rc file]              Positional argument; test this init script.
-
-Multiple script mode options:
-  --out_system=DIR            Path to the output product directory for the system partition.
-  --out_system_ext=DIR        Path to the output product directory for the system_ext partition.
-  --out_odm=DIR               Path to the output product directory for the odm partition.
-  --out_vendor=DIR            Path to the output product directory for the vendor partition.
-  --out_product=DIR           Path to the output product directory for the product partition.
-)");
+    std::cout << "usage: host_init_verifier [options] <init rc file>\n"
+                 "\n"
+                 "Tests an init script for correctness\n"
+                 "\n"
+                 "-p FILE\tSearch this passwd file for users and groups\n"
+                 "--property_contexts=FILE\t Use this file for property_contexts\n"
+              << std::endl;
 }
 
 Result<InterfaceInheritanceHierarchyMap> ReadInterfaceInheritanceHierarchy() {
@@ -221,18 +203,12 @@ int main(int argc, char** argv) {
     android::base::SetMinimumLogSeverity(android::base::ERROR);
 
     auto property_infos = std::vector<PropertyInfoEntry>();
-    std::map<std::string, std::string> partition_map;
 
     while (true) {
         static const char kPropertyContexts[] = "property-contexts=";
         static const struct option long_options[] = {
                 {"help", no_argument, nullptr, 'h'},
                 {kPropertyContexts, required_argument, nullptr, 0},
-                {"out_system", required_argument, nullptr, 0},
-                {"out_system_ext", required_argument, nullptr, 0},
-                {"out_odm", required_argument, nullptr, 0},
-                {"out_vendor", required_argument, nullptr, 0},
-                {"out_product", required_argument, nullptr, 0},
                 {nullptr, 0, nullptr, 0},
         };
 
@@ -248,16 +224,6 @@ int main(int argc, char** argv) {
                 if (long_options[option_index].name == kPropertyContexts) {
                     HandlePropertyContexts(optarg, &property_infos);
                 }
-                for (const auto& p : partition_search_order) {
-                    if (long_options[option_index].name == "out_" + p) {
-                        if (partition_map.find(p) != partition_map.end()) {
-                            PrintUsage();
-                            return EXIT_FAILURE;
-                        }
-                        partition_map[p] =
-                                EndsWith(optarg, "/") ? optarg : std::string(optarg) + "/";
-                    }
-                }
                 break;
             case 'h':
                 PrintUsage();
@@ -274,9 +240,7 @@ int main(int argc, char** argv) {
     argc -= optind;
     argv += optind;
 
-    // If provided, use the partition map to check multiple init rc files.
-    // Otherwise, check a single init rc file.
-    if ((!partition_map.empty() && argc != 0) || (partition_map.empty() && argc != 1)) {
+    if (argc != 1) {
         PrintUsage();
         return EXIT_FAILURE;
     }
@@ -298,42 +262,24 @@ int main(int argc, char** argv) {
 
     property_info_area = reinterpret_cast<const PropertyInfoArea*>(serialized_contexts.c_str());
 
-    if (!partition_map.empty()) {
-        std::vector<std::string> vendor_prefixes;
-        for (const auto& partition : {"vendor", "odm"}) {
-            if (partition_map.find(partition) != partition_map.end()) {
-                vendor_prefixes.push_back(partition_map.at(partition));
-            }
-        }
-        InitializeHostSubcontext(vendor_prefixes);
-    }
-
     const BuiltinFunctionMap& function_map = GetBuiltinFunctionMap();
     Action::set_function_map(&function_map);
     ActionManager& am = ActionManager::GetInstance();
     ServiceList& sl = ServiceList::GetInstance();
     Parser parser;
-    parser.AddSectionParser("service",
-                            std::make_unique<ServiceParser>(&sl, GetSubcontext(),
-                                                            *interface_inheritance_hierarchy_map));
-    parser.AddSectionParser("on", std::make_unique<ActionParser>(&am, GetSubcontext()));
+    parser.AddSectionParser("service", std::make_unique<ServiceParser>(
+                                               &sl, nullptr, *interface_inheritance_hierarchy_map));
+    parser.AddSectionParser("on", std::make_unique<ActionParser>(&am, nullptr));
     parser.AddSectionParser("import", std::make_unique<HostImportParser>());
 
-    if (!partition_map.empty()) {
-        for (const auto& p : partition_search_order) {
-            if (partition_map.find(p) != partition_map.end()) {
-                parser.ParseConfig(partition_map.at(p) + "etc/init");
-            }
-        }
-    } else {
-        if (!parser.ParseConfigFileInsecure(*argv)) {
-            LOG(ERROR) << "Failed to open init rc script '" << *argv << "'";
-            return EXIT_FAILURE;
-        }
+    if (!parser.ParseConfigFileInsecure(*argv)) {
+        LOG(ERROR) << "Failed to open init rc script '" << *argv << "'";
+        return EXIT_FAILURE;
     }
     size_t failures = parser.parse_error_count() + am.CheckAllCommands() + sl.CheckAllCommands();
     if (failures > 0) {
-        LOG(ERROR) << "Failed to parse init scripts with " << failures << " error(s).";
+        LOG(ERROR) << "Failed to parse init script '" << *argv << "' with " << failures
+                   << " errors";
         return EXIT_FAILURE;
     }
     return EXIT_SUCCESS;
diff --git a/init/service.cpp b/init/service.cpp
index c5d89752ff2d0e06e32992db19ad1881d63763ad..dabba70e14482166082bc60432f489344e2a821e 100644
--- a/init/service.cpp
+++ b/init/service.cpp
@@ -154,7 +154,6 @@ Service::Service(const std::string& name, unsigned flags, uid_t uid, gid_t gid,
                  .priority = 0},
       namespaces_{.flags = namespace_flags},
       seclabel_(seclabel),
-      subcontext_(subcontext_for_restart_commands),
       onrestart_(false, subcontext_for_restart_commands, "<Service '" + name + "' onrestart>", 0,
                  "onrestart", {}),
       oom_score_adjust_(DEFAULT_OOM_SCORE_ADJUST),
diff --git a/init/service.h b/init/service.h
index c314aa1c6cb8383d93d9a4acb2dd878e8dc1be47..b774433617b77badb5087fb3f2a9acc0bba328dd 100644
--- a/init/service.h
+++ b/init/service.h
@@ -141,7 +141,6 @@ class Service {
             flags_ &= ~SVC_ONESHOT;
         }
     }
-    Subcontext* subcontext() const { return subcontext_; }
 
   private:
     void NotifyStateChange(const std::string& new_state) const;
@@ -182,7 +181,6 @@ class Service {
     std::vector<FileDescriptor> files_;
     std::vector<std::pair<std::string, std::string>> environment_vars_;
 
-    Subcontext* subcontext_;
     Action onrestart_;  // Commands to execute on restart.
 
     std::vector<std::string> writepid_files_;
diff --git a/init/service_parser.cpp b/init/service_parser.cpp
index 1ee309d98b758c3aefb56de65ccf8b9fd5792a08..b36c6688354462210abc09db7735d0039255eba3 100644
--- a/init/service_parser.cpp
+++ b/init/service_parser.cpp
@@ -698,14 +698,6 @@ Result<void> ServiceParser::EndSection() {
                            << "' with a config in APEX";
         }
 
-        std::string context = service_->subcontext() ? service_->subcontext()->context() : "";
-        std::string old_context =
-                old_service->subcontext() ? old_service->subcontext()->context() : "";
-        if (context != old_context) {
-            return Error() << "service '" << service_->name() << "' overrides another service "
-                           << "across the treble boundary.";
-        }
-
         service_list_->RemoveService(*old_service);
         old_service = nullptr;
     }
diff --git a/init/subcontext.cpp b/init/subcontext.cpp
index 4e573854eda7c52b47bcebc897e6f0d2e3cc745a..cac91f9b19b838079ae5f81b7e33bb21f636cbf7 100644
--- a/init/subcontext.cpp
+++ b/init/subcontext.cpp
@@ -350,9 +350,6 @@ void InitializeSubcontext() {
                 new Subcontext(std::vector<std::string>{"/vendor", "/odm"}, kVendorContext));
     }
 }
-void InitializeHostSubcontext(std::vector<std::string> vendor_prefixes) {
-    subcontext.reset(new Subcontext(vendor_prefixes, kVendorContext, /*host=*/true));
-}
 
 Subcontext* GetSubcontext() {
     return subcontext.get();
diff --git a/init/subcontext.h b/init/subcontext.h
index cb4138e69f3880af184e1f1a4960c58b37ddebf1..788d3be6cfe5c8ba4f638abed0b0dbfd62ec02da 100644
--- a/init/subcontext.h
+++ b/init/subcontext.h
@@ -36,11 +36,9 @@ static constexpr const char kTestContext[] = "test-test-test";
 
 class Subcontext {
   public:
-    Subcontext(std::vector<std::string> path_prefixes, std::string context, bool host = false)
+    Subcontext(std::vector<std::string> path_prefixes, std::string context)
         : path_prefixes_(std::move(path_prefixes)), context_(std::move(context)), pid_(0) {
-        if (!host) {
-            Fork();
-        }
+        Fork();
     }
 
     Result<void> Execute(const std::vector<std::string>& args);
@@ -63,7 +61,6 @@ class Subcontext {
 
 int SubcontextMain(int argc, char** argv, const BuiltinFunctionMap* function_map);
 void InitializeSubcontext();
-void InitializeHostSubcontext(std::vector<std::string> vendor_prefixes);
 Subcontext* GetSubcontext();
 bool SubcontextChildReap(pid_t pid);
 void SubcontextTerminate();
